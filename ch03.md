# 视频编码概念

## 3.1 引言

**compress vb.: to squeeze together or compact into less space; condense**  
**compression noun: the act of compression or the condition of being compressed**

压缩是将数据压缩成更少 bit 的行为过程。视频压缩(视频编码)是将数字视频转换成适合传输或存储的格式的过程,同时通常会减少比特数。原始视频(未压缩视频)通常需要非常大的比特率，如第二章中的 216Mbit/s。因此，压缩对于数字视频的实际存储和传输是必要的。

压缩涉及一对互补的系统，一个压缩器(编码器)和一个解压器(解码器)。编码器在传输或存储之前，将源数据转换成占用较少比特数的压缩形式，解码器将压缩形式转换回原始视频数据。编码器/解码器对通常被描述为编解码器(编解码器)(图 3.1)。

![Figure 3.1 Encoder/Decoder](https://github.com/lazybing/THE-H.264-ADVANCED-VIDEO-COMPRESSION-STANDARD/blob/main/image/Figure3.1.png?raw=true)

数据压缩是通过消除冗余来实现的，即消除那些数据的重建并不是必须的组件。数据的许多类型包含统计冗余，并且可以使用无损压缩进行有效压缩，这种情况，解码器端输出的重建数据是原始数据的完美副本。不幸的是，图像和视频信息的无损压缩只能提供中等程度的压缩。无损图像压缩标准(例如JPEG-LS)能够实现的最大压缩率是3-4倍左右。有损压缩对于实现高压缩率是由必要的。在有损压缩系统中，解压缩后的数据与原数据不相同，并且以视觉质量损失为代价来实现更高的压缩比。有损视频压缩系统基于去除主观冗余的原理，即图像或视频序列中的元素可以在不显著影响观看者对视觉质量的感知情况下被去除。

大多数视频编码方法利用时间和空间冗余来实现压缩。在时域中，几乎同时被捕获的视频帧之间通常高度的相似性或相关性。时间上相邻的帧，即时间顺序上的连续帧，通常高度相关，特别是在时间采样率或帧率高的情况下。在空间域中，彼此接近的像素（样本）之间通常存在高度相关性，即相邻样本的值通常非常相似（图3.2）。

H.264高级视频编码标准与其他流行的压缩格式（如MPEG-2视频、MPEG-4视频、H.263、VC-1等）共享许多共同的特性。这些格式中的每一种都是基于使用预测和/或基于块的运动补偿、变换、量化和熵编码的编解码器“模型”。在这一章中，我们研究了该模型的主要组成部分，从预测模型开始，包括帧内预测、运动估计和运动补偿，接着是图像变换、量化、预测编码和熵编码。本章最后介绍了基本模型的“演变”，接着介绍了对图像样本块进行编码和解码的过程。

## 3.2 Video CODEC

视频编解码器（图 3.3）将源图像与视频序列编码为压缩形式，并对其进行解码以产生源序列的副本或近似值。如果解码的视频序列与原视频序列相同，则编码过程是无损的；如果解码序列与原始序列不同，则该过程是有损的。

编解码器通过**模型**表示原视频序列，这是一种高效的编码表示，可用于重建视频数据的近似值。理想情况下，模型应该使用尽可能少的比特和尽可能高的保真度来表示序列。压缩效率和高质量这两个目标通常是冲突的，即较低的压缩比特率通常在解码器处产生降低的图像质量。

视频编码器（图3.3）由三个主要功能单元组成：**预测模型**、**空间模型**和**熵编码器**。预测模型的输入是未压缩的原始视频序列。预测模型试图通过利用相邻视频帧和/或相邻图像样本之间的相似性来减少冗余，通常通过构建当前视频帧或视频数据块的预测。在 H.264/AVC 中，根据当前帧或一个或多个先前和/或未来帧中的数据形成预测。它是通过相邻图像样本进行空间外推、帧内预测或通过补偿帧间差异、帧间或运动补偿预测来创建的。预测模型的输出是通过从实际的当前帧减去预测而产生的残余帧，以及指示帧内预测类型或描述如何补偿运动的一组模型参数。

残差帧形成了空间模型的输入，利用残差帧中的局部样本之间的相似性来减少空间冗余。在 H.264/AVC 中，这是通过对残余样本应用变换并量化结果来实现的。变换将样本转换为另一个域，在该域中它们由变换系数表示。系数被量化以去除不重要的值，留下少量的重要系数，其提供剩余帧的更紧凑表示。空间模型的输出是一组量化的变换系数。

预测模型的参数（即帧内预测模式或帧间预测模式和运动矢量）、以及空间模型（即系数）由熵编码器压缩。这消除了数据中的统计冗余，例如用短二进制码表示通常出现的向量和系数。熵编码器产生可被传输和/或存储的压缩比特流或文件。压缩序列由编码预测参数、编码残差系数和头信息组成。

视频解码器从压缩比特流重构视频帧。通过上解码器对系数和预测参数进行解码，然后对空间模型进行解码以重构残差帧的版本。解码器使用预测参数以及先前解码的图像像素来创建当前帧的预测，并通过将剩余帧添加到该预测中的重构帧本身。

## 3.3 预测模型

要处理的数据是当前帧或场中的一组图像样本。预测模型的目标是通过形成数据的预测并从当前数据中减去该预测来降低冗余。预测可能来自先前编码的帧(时间预测)或同一帧中先前编码的图像样本（空间预测）。该过程的输出是一组残差或差分样本，预测过程越精确，残差中包含的能量就越少。残差被编码并发送到解码器，解码器重建相同的预测，以便它可以添加解码残差并重构当前帧。为了解码器能够创建相同的预测，编码器必须使用解码器可用的数据，即已经编码和发送的数据来形成预测。

### 3.3.1 时域预测

预测帧是从一个或多个过去、将来的帧（称为参考帧）创建出的。通常可以通过补偿参考帧和当前帧之间的运动来提高预测精读。

#### 3.3.1.1 从之前帧预测

时间预测最简单方法是使用前一帧作为当前帧的预测器。一个视频序列的两个连续帧如图 3.4 和图 3.5 所示。第 1 帧作为第 2 帧的预测器，从当前帧(第 2 帧)减去预测器(第 1 帧)形成的残差如图 3.6 所示。在该图像中，中灰色表示差值为零，而浅灰色或深灰色分别对应于正差值和负差值。简单预测的明显问题是，在剩余帧（由亮区和暗区表示）中仍然存在大量能量，这意味着在时间预测之后仍然有大量信息要压缩。大部分剩余能量是由于两针之间的物体运动引起的，通过补偿两帧之间的运动可以形成更好的预测。

#### 3.3.1.2 运动引起的变换

视频帧之间变换的原因包括运动、未覆盖区域和光照变化。运动类型包括刚性物体运动（例如移动的汽车）、可变性物体运动（例如说话的人）和相机运动（例如平移、倾斜、变焦和旋转）。未覆盖区域可能是被移动物体覆盖的场景背景的一部分。除了未覆盖区域和光照变化之外，这些差异对应于帧之间的像素移动。可以估计连续帧之间的每个像素的轨迹，产生称之为光流的像素轨迹场。图 3.7 显示了图 3.4 和图 3.5 框架的光流场。完整的场包括每个像素位置的流矢量，但是为了清楚起见，对场进行了子采样，以便仅显示每 2 个像素的矢量。

如果准确地知道光流场，则可以沿着光流矢量从参考帧移动每个像素来形成对当前帧的大多数像素的准确预测。然而，这不是一种实用的运动补偿方法，原因有几个。光流的精确计算是非常计算密集的，因为更精确的方法会对每个像素都使用迭代过程，并且对于解码器重建预测帧，将有必要将每个像素的光流矢量发送到解码器，从而产生大量传输数据并降低小残差的优点。

#### 3.3.1.3 基于块的运动估计与补偿

一种实用并且被广泛使用的运动补偿方法是补偿当前帧的矩形部分或“块”的运动。对当前帧中的每个 MxN 样本块执行以下步骤：

* 搜索参考帧中的某个区域（过去或未来帧），以找到近似的 MxN 采样区域。可通过将当前帧中的 MxN 块与搜索区域中的一些或所有可能的MxN 区域（例如，以当前块位置为中心的区域）进行比较，并找到给出“最佳”匹配的区域来执行该搜索。一种流行的匹配准则是从当前的 MxN 块中减去候选区域所形成的残差中的能量，从而选择残差能量最小的候选区域作为最佳匹配。这种寻找最佳匹配的过程称为**运动估计**。  
* 所选的候选区域成为当前 MxN 块的预测器（运动补偿预测），并且从当前块中减去该候选区域形成剩余 MxN 块（**运动补偿**）。  
* 对剩余块进行编码和发送，并且还发送当前块与候选区域（**运动矢量**）的位置之间的偏移。  

解码器使用接收到的运动矢量来重新创建预测器区域。它对剩余块进行解码，将其添加到预测器中，并重建原始块的版本。

基于块的运动补偿是有许多原因的。它相对简单且易于计算，适合于矩形视频帧和基于块的图像变换（如离散余弦变换），为许多视频序列提供了合理有效的时间模型。但也有一些缺点。例如，“真实”对象很少有与矩形边界匹配的整齐边缘，对象通常在帧之间以小数点的像素位置移动，并且许多类型的对象运动很难使用基于块的方法进行补偿，例如可变形对象、旋转、扭曲和复杂运动（如烟云）。尽管存在这些缺点，基于块的运动补偿仍然是当前所有视频编码标准所使用的时间预测模型的基础。

#### 3.3.1.4 宏块的运动补偿预测

在包括MPEG-1、MPEG-2、MPEG-4、H.261、H.263和H.264在内的许多重要视频编码标准中，与帧的16×16像素区域相对应的宏块，是用于运动补偿预测的基本单元。对于流行的 420 格式的源视频材料（第2章），宏块的组织如图 3.8 所示。源帧的 16×16 像素区域由四个 8×8 采样块中排列的256个亮度样本、一个 8×8 块中的 64 个红色色度样本和一个 8×8 块中的 64 个蓝色色度样本表示，总共给出六个 8×8 块。H.264/AVC编解码器以宏块为单位处理每个视频帧。

**运动估计：**  

宏块的运动估计涉是在参考帧中找到与当前宏块匹配的 16×16 采样区域。参考帧是来自序列的先前编码的帧，在显示顺序中它可能在当前帧之前或之后。搜索以当前宏块位置为中心的参考帧中的搜索区域，并选择搜索区域中使匹配标准最小化的 16×16 区域作为“最佳匹配”（图 3.9 ）。

**运动补偿：**  

从当前宏块中减去参考帧中所选择的“最佳”匹配区域的亮度和色度样本以产生剩余宏块，该剩余宏块与描述最佳匹配区域相对于当前宏块位置的位置的运动矢量一起编码和传输。  

基于基本的运动估计和补偿过程，有很多变种。参考帧可以是时间顺序上的先前帧、未来帧或来自两个或多个先前编码帧的预测的组合。如果选择未来帧作为参考，则必须在当前帧之前对该帧进行编码，即编码帧必须与视频帧序列顺序不同。如果参考帧和当前帧之间存在显著变化，例如场景变化或未覆盖区域，在没有运动补偿的情况下对宏块进行编码可能更有效，因此编码器可能为每个宏块选择使用帧内预测的帧内模式编码或具有运动补偿预测的帧间模式编码。视频场景中的运动对象很少遵循“整齐”的16×16像素边界，因此使用可变块大小进行运动估计和补偿可能更有效。对象可以在帧之间移动小数像素，例如在水平方向上移动2.78像素而不是2.0像素，并且可以通过在搜索这些位置以获得最佳匹配之前将参考帧内插到子像素位置来形成更好的预测。

#### 3.3.1.5 运动补偿块大小

一个视频序列中的两个连续帧如图 3.10 和图 3.11 所示。从第 2 帧减去第 1 帧而不进行运动补偿，以产生剩余帧（图 3.12）。通过对每一个 16×16 宏块进行运动补偿，可以降低残差中的能量（图3.13）。每 8×8块 而不是每 16×16 宏块的运动补偿进一步降低了剩余能量（图3.14），每 4×4 块的运动补偿给出的剩余能量最小（图3.15）。这些例子表明，较小的运动补偿块大小可以产生更好的运动补偿结果。然而，较小的块大小导致复杂性增加，需要执行更多的搜索操作，并且需要传输的运动矢量的数量增加。发送每个运动矢量需要传输比特，矢量的额外开销可能超过减少剩余能量的好处。一种有效的折衷方法是使块大小适应图片特征，例如在帧的平坦均匀区域中选择大块大小，并在高细节和复杂运动区域周围选择小块大小（第6章）。

#### 3.3.1.6 亚像素运动补偿

图 3.16 显示了参考框架部分的特写视图。在某些情况下，根据参考帧中的内插样本位置进行预测可以形成更好的运动补偿预测。在图 3.17 中，参考区域像素被内插到半像素位置，并且通过搜索内插的样本可以找到当前宏块的更好匹配。亚像素运动估计和补偿包括搜索亚像素插值位置和整数像素位置，并选择最佳匹配位置和最小化剩余能量。图 3.18 显示了四分之一像素运动估计的概念。在第一阶段，运动估计在整数像素网格（圆）上找到最佳匹配。编码器搜索紧靠此最佳匹配（正方形）的半像素位置，以查看是否可以改进匹配，如果需要，则搜索紧靠最佳半像素位置（三角形）的四分之一像素位置。从当前块或宏块中减去整数、半像素或四分之一像素位置的最终匹配。

图3.19中的残差是使用4×4像素的块大小通过半像素插值产生的，并且残差能量小于图3.15。这种方法可以通过在1/4像素网格上插值得到更小的残差来进一步扩展（图3.20）。一般而言，“更精细”插值提供更好的运动补偿性能，以增加复杂性为代价产生更小的残差。随着插值步长的增加，性能增益趋于减小。半像素内插比整数像素运动补偿有显著的增益，四分之一像素内插有适度的进一步改进，八分之一像素内插有少量的进一步改进，以此类推。

表3.1给出了通过亚像素插值实现的一些性能示例。从当前帧中减去运动补偿参考帧（序列中的前一帧），表中列出了由绝对误差之和（SAE）近似的残差能量。SAE越低，运动补偿性能越好。在每种情况下，与整数像素补偿相比，亚像素运动补偿提供了改进的性能。从整数到半像素的改进比从半像素到四分之一像素的进一步改进更为显著。序列“Grasses”具有高度复杂的运动，特别难以进行运动补偿，因此具有较大的SAE；'“小提琴”和“Carphone”不太复杂，运动补偿产生的SAE值较小。

使用1/4像素插值搜索匹配的4×4块要比不使用插值搜索16×16块复杂得多。除了额外的复杂性之外，还有一个编码惩罚，因为每个块的向量必须被编码并传输到接收器，以便正确地重建图像。随着块大小的减小，必须传输的向量的数目增加。需要更多位来表示1/2或1/4像素向量，因为向量的小数部分（例如0.25或0.5）必须与整数部分一起编码。图3.21绘制了与图3.13的残差一起传输的整数运动矢量。图3.20的残差所需的运动矢量绘制在图3.22中，其中有16倍的矢量，每个矢量由两个分数DX和DY表示，精度为1/4像素。因此，与更复杂的运动补偿方案相关联的压缩效率存在权衡，因为更精确的运动补偿需要更多比特来编码向量场，但是对残差进行编码的比特数较少，而较不精确的运动补偿要求向量场的比特数较少，而残差的比特数较多。使用复杂的插值滤波器可以提高亚像素插值算法的效率。

### 3.3.2 空间模型：帧内预测

从同一帧中先前编码的样本创建对当前图像样本块的预测。图3.23显示了当前帧中要预测的块（中心）。假设图像样本的块按光栅扫描顺序编码（并非总是这样），则上/左阴影块可用于帧内预测。这些块已经被编码并放置在输出比特流中。当解码器处理当前块时，阴影化的上/左块已经被解码并且可以用于重新创建预测。

人们提出了许多不同的帧内预测方法。H.264/AVC使用空间外推来创建块或宏块的帧内预测。图3.24显示了一般概念。通过从当前块的顶部和/或左侧外推样本来形成一个或多个预测。一般来说，最近的样本最有可能与当前块中的样本高度相关（图3.25），因此仅使用沿上边缘和/或左边缘的像素来创建预测块。一旦预测已经生成，就以与帧间预测类似的方式从当前块中减去它以形成残差。对残差进行变换和编码，并指示如何生成预测。第六章详细介绍了帧内预测。

## 3.4 图像模型

自然视频图像由采样值网格组成。由于相邻图像样本之间的高度相关性，自然图像很男按照原始形式压缩。图3.25 显示了自然视频的二维自相关函数（图3.4），其中每个位置的图像高度表示原始图像和自身空间移动副本之间的相似性。图像中心的峰值对应于零偏移。当空间移位的拷贝在任何方向上，从原始图像移开时，如图所示，该函数衰减，并且渐变斜率指示局部邻域内的图像样本高度相关。

如图 3.20 所示的运动补偿残差图像具有自相关函数(图 3.26)，该函数随着空间偏移的增加二迅速下降，表明相邻样本之间的相关性较弱。有效的运动补偿或帧内预测降低了残差中的局部相关性，使其比原始视频帧更易于压缩。图像模型的功能使进一步去相关图像或残差数据，并将其转换为可以使用熵编码器有效亚索的形式。实际的图像模型通常有三个主要的组成部分，变换来消除和压缩数据，量化来降低变换数据的精度，重新排序来排列数据以将重要值组合在一起。

### 3.4.1 预测图像编码

运动补偿是预测编码的示例，其中编码器基于先前或未来帧创建当前帧的区域的预测，并从当前区域减去该预测以形成残差。如果预测成功，则残差中的能量低于原始帧中的能量，并且残差可以用较少的比特来表示。

预测编码是早期图像压缩算法的基础，是 H.264 帧内编码的重要组成部分，参见第 3.3.2 节和第 6 章。空间预测涉及从相同图像或帧中先前传输的样本预测图像样本或区域，有时被描述为“差分脉冲编码调制(DPCM)”，这是从电信系统中差分编码 PCM 样本的方法中借用的术语。

图3.27显示了要编码的像素X。如果帧是按光栅顺序处理的，那么当前行和前一行中的像素A、B和C在编码器和解码器中都可用，因为它们应该在X之前已经被解码。编码器基于先前编码的像素的一些组合形成对X的预测，从X减去该预测，并对残差（减去的结果）进行编码。解码器形成相同的预测，并将解码后的残差相加以重构像素。

> **示例**
> 
> 编码预测 P(X) = (2A + B + C)/4  
> 残差 R(X) = X - P(X) 被编码并传输  
> 解码器解码 R(X) 并形成相同的预测：`P(X) = (2A + B + C)/4`  
> 重建像素 X = R(X) + P(X)  

如果编码过程是有损的，即如果残差被量化-参见第3.4.3节，那么由于编码过程中的损失，解码的像素A′、B′和C′可能与原始的A、B和C不相同，因此上述过程可能导致编码器和解码器之间的累积失配或“漂移”。为了避免这种情况，编码器应该自己解码剩余的R'（X）并重建每个像素。因此，编码器使用解码像素A′、B′和C′来形成预测，即在上述示例中P（X）=（2A′+B′+C'）/4。这样，编码器和解码器使用相同的预测P（X），并且避免了漂移。

这种方法的压缩效率取决于预测P（X）的精度。如果预测是准确的，即P（X）是X的近似值，那么剩余能量将很小。然而，预测期适用于对复杂图像的所有区域是不可能的；根据图像的局部统计来调整预测期可能获得更好的性能（例如，对于平坦纹理、强垂直纹理、强水平纹理的区域使用不同的预测器）。编码器必须向解码器指示预测器的选择，因此在有效的预测和向预测器的选择发送信号所需的额外比特之间存在折衷。

### 3.4.2 变换编码

#### 3.4.2.1 概述

图像或视频编解码器中的变换阶段的目的是将图像或运动补偿的残差数据转换到另一域，即变换域。变换的选择取决于许多条件：

1. 变换域中的数据应该去相关，即在最小的相互依赖范围内分离出组件并且紧凑（即变换数据中的大部分能量应该集中到少量值中）。  
2. 这种变换是可逆的。
3. 变换应具有计算可处理性。例如，低内存要求、可使用有限精度算法实现、算术运算次数少等。

许多变换已经被提出用于图像和视频压缩，最流行的变换往往分为两类，基于块的和基于图像的。基于块的变换的例子包括Karhunen-Loeve变换（KLT）、奇异值分解（SVD）和一直流行的离散余弦变换（DCT）及其近似。其中每一个都对 NxN 图像块或残差样本进行操作，因此图像以块为单位进行处理。块变换具有较低的内存需求，非常适合基于块的运动补偿残差的压缩，但往往会收到块边缘伪影（块效应）的影响。基于图像的变换操作整个图像或帧，或者称为“平铺”的图像的很大一部分。最流行的图像变换是离散小波变换，DWT 或仅仅是“小波”。图像变换（如DWT）已被证明比用于静止图像压缩的块变换执行得更好，但它们往往具有更高的内存要求，因此整个图像或块作为一个单元进行处理，并且它们不一定与机遇块的运动补偿很好地“适配”。DCT 和 DWT 都是 MPEG-4 视频中的特征，与 H.264 中包含的 DCT 近似，并且在下面的部分中进一步讨论。

#### 3.4.2.2 DCT

离散余弦变换（DCT）对 X（NxN 个样本块，通常是图像样本或预测后的残差）进行运算，以创建Y（NxN 个系数块）。离散余弦变换及其逆变换的作用，可以用变换矩阵 a 来描述。

#### 3.4.2.3 小波变换

在图像压缩中流行的“小波变换”是基于一组系数相当于离散小波函数的滤波器。变换的基本操作如下，应用于包含N个样本的离散信号。对信号应用一对滤波器，将其分解为低频带（L）和高频带（H）。每个频带以二的因子进行二次采样，因此两个频带每个包含N/2个样本。如果正确选择过滤器，这种操作是可逆的。

### 3.4.3 量化

量化器将具有值 X 的范围的信号映射到具有减小的值 Y 的范围的量化信号。由于可能值的范围较小，因此应该可以用比原始值更小的比特来表示量化信号。**标量量化器**将输入信号的一个样本映射到一个量化输出值，**向量量化器**将一组输入样本“向量”映射到一组量化值。

## 3.5 熵编码

熵编码将表示视频序列元素的一系列符号转换成适于传输或存储的压缩比特流。输入符号可包括量化变换系数、运动级别或者按第 3.4.4 节所述编码的非零系数、具有整数或亚像素分辨率的运动矢量、指示序列中重新同步点的标记码、宏块头、图片头、序列头等和补充信息；边信息对于正确解码不是必需的。

### 3.5.1 预测编码

图片中的局部区域的某些符号是高度相关的。例如，相邻帧内编码块的像素的平均值或 DC 值可能非常相似，相邻运动矢量可能具有相似的 x 和 y 位移等。通过从先前编码的数据预测当前块或宏块的元素并编码预测值和实际值之间的差异，可以提高编码效率。

块或宏块的运动矢量指示到先前编码帧中的预测参考的偏移。相邻块或宏块的向量通常是相关的，因为物体运动可能跨越帧的大区域。对于较小的块大小，例如 4x4 块向量(图3.22)或有较大运动幅度的物体，尤其如此。可以通过从先前编码的向量预测每个运动向量来改进运动向量场的压缩。当前宏块 X 的向量的简单预测是水平相邻的宏块 A（图3.45）；或者，可以使用三个或更多先前编码的向量来预测宏块 X 处的向量，例如图 3.45 中的A、B 和 C。对预测运动矢量和实际运动矢量之间的差，即运动矢量差或MVD进行编码和传输。

量化参数或量化器步长控制压缩效率和图像质量之间的权衡。在实时视频编解码中，可能需要修改编码帧内的量化，例如改变压缩比，以便将编码比特率与传输信道速率匹配。在连续编码的宏块之间，通常只需少量改变参数即可。修改后的量化参数必须用信号通知解码器，并且代替发送新的量化参数值，可以优选发送增量或差值，例如 +/-1或+/-2，表示所需的更改。编码一个小的增量值比编码一个全新的量化参数需要更小的位。

### 3.5.2 变长编码

可变长度编码器将输入符号映射到一系列码子、可变长度代码或 VLC。每个符号映射到一个码字，码字可能具有不同的长度，但每个码字必须包含整数位数。频繁出现的符号用短 VLC 表示，儿不太常见的符号用长 VLC 表示。在足够多的编码符号上，这会导致数据压缩。

#### 3.5.2.1 Huffman coding

哈夫曼编码根据不同符号的出现概率为每个符号分配 VLC。根据 Huffman 在 1952 年提出的原始方案，需要计算每个符号的出现概率并构造一组可变长度码字。这一过程将通过两个例子加以说明。  

**Example 1:Huffman coding, Sequence 1 motion vectors**

需要对视频序列 1 的运动矢量差分数据(MVD)进行编码。表 3.2 列出了编码序列中最常见的运动矢量的概率及其信息内容 log2(1/p)。为了实现最佳压缩，每个值都应该精确地用 log2(1/p)位表示。 0 是最常见的值，较大运动矢量的概率下降。该分部代表包含中等运动的序列。

Table 3.2 Probability of occurrence of motion vectors in sequence 1

| Vector | Probability p | log2(1/p) |  
| :----: | :-----: | :----: |  
| -2 | 0.1 | 3.32 |   
| -1 | 0.2 | 2.32 |  
| 0 | 0.4 | 1.32 |  
| 1 | 0.2 | 2.32 |  
| 2 | 0.2 | 3.32 |  

1. 生成哈夫曼代码树

要为这组数据生成哈夫曼代码表，请执行一下迭代过程：1. 按概率递增的顺序排列数据列表。2. 将两个概率最低的数据组合成一个“节点”，并将数据项的联合概率分配给该节点。3. 按概率递增的顺序重新排列其余数据项和节点，并重复步骤2。

重复此过程，直到有一个“根”节点包含“下面”列出的所有其他节点和数据项。该程序如图3.46所示。

| Original list | The data items are shown as square boxes. Vectors (−2) and (+2) have the lowest probability and these are the first candidates for merging to form node ‘A’. |  
| :----: | :----: |   
| Stage 1: | The newly-created node ‘A’, shown as a circle, has a probability of 0.2, from the combined probabilities of (−2) and (2). There are now three items with probability 0.2. Choose vectors (−1) and (1) and merge to form node ‘B’. |  
| Stage 2: | A now has the lowest probability (0.2) followed by B and the vector 0; choose A and B as the next candidates for merging to form ‘C’. |  
| Stage 3: | Node C and vector (0) are merged to form ‘D’. |  
| Final tree | The data items have all been incorporated into a binary ‘tree’ containing five data values and four nodes. Each data item is a ‘leaf’ of the tree. |  

2. 编码

二叉树的每个叶子都映射到一个可变长度的代码。为了找到这段代码，将树从根节点(在本例中为 D)遍历到叶或数据项。如图 3.46 的最后一课树所示，每个分支的代码后面都会附加一个 0 或 1,0表示上分支，1 表示下分支，给出一下代码集（表3.3）。

Table 3.3 Huffman codes for sequence 1 motion vectors

| Vector | Code | Bits (actual) | Bits (ideal) |  
| :----: | :----: | :------: | :-----: |  
| 0 | 1 | 1 | 1.32 |  
| 1 | 011 | 3 | 2.32 |  
| -1 | 010 | 3 | 2.32 | 
| 2 | 001 | 3 | 3.32 |  
| -2 | 000 | 3 | 3.32 |  

编码是通过为每个数据项传输适当的代码来实现的。请注意，生成树后，diam可能存储在查找表中。

高概率数据项被分配短代码，例如，最常见的向量'0'为 1 位。然而，向量(-2, 2, -1, 1)均被分配为 3 位代码，尽管 -1 和 1 的概率高于 -2 和 2。哈夫曼代码的长度(每个位整数位数)与 log2(1/p)给出的理想长度不匹配。没有任何代码包含任何其他代码作为前缀，这意味着，从左侧位读取时，每个代码都是唯一可解码的。

例如，向量系列（1，0，−2） 将作为二进制序列0111000传输。

3. 解码

为了解码数据，解码器必须具有哈夫曼代码树或查找表的本地副本。这可以通过发送查找表本身或者通过在发送编码数据之前发送数据和概率的列表来实现。每个唯一可解码的代码都会转换回原始数据，例如：1. `011`解码成`(1)` 2. `1`解码成`(0)` 3. `000`解码成`-2`。

**Example 2: Huffman coding, sequence 2 motion vectors**

对具有不同运动向量概率分布的第二序列重复上述过程会给出不同的结果。概率在表 3.4 中列出，并注意，零向量更可能出现在本例中，代码一个几乎没有移动的序列。

Table 3.5 Huffman codes for sequence 2 motion vectors

| Vector | Code | Bits(actual) | Bits(ideal) |  
| :----: | :----: | :------: | :-----: |  
| 0 | 1 | 1 | 0.32 |  
| 1 | 01 | 2 | 3.64 |  
| -1 | 001 | 3 | 3.84 |  
| 2 | 0001 | 4 | 5.06 |  
| -2 | 0000 | 4 | 5.64 |  

图3.47 给出了相应的哈夫曼树。由于概率的分布，树的形状发生了变化，这产生了一组不同的哈弗曼码。如表 3.5 所示。树中仍然有四个节点，此数据项的数量(5)少一个，就像哈弗曼编码一样。

如果概率分布是准确的，哈夫曼编码提供了原始数据的相对紧凑的表示。在这些示例中，频繁出现的（0）向量有效地表示为单个比特。然而，为了实现最佳压缩，由于两个序列的概率分布不同，因此需要为每个序列提供单独的代码表。对于序列2中的向量“0”，由于整数长度代码的要求而导致的潜在压缩效率损失非常明显，因为最佳比特数（信息内容）为0.32，但哈夫曼编码可实现的最佳比特数为1。

#### 3.5.2.2 基于预计算哈夫曼编码




## 3.7 总结

本章描述的视频编码工具，运动补偿预测、变换编码、量化和熵编码，构成了可靠和有效的编码模型的基础，该模型在视频压缩领域占据主导地位超过 10 年。这个编码模型是 H.264/AVC 标准的核心。下一章介绍了 H.264/AVC 的主要特性，并在接下来的章节中详细讨论了该标准。


