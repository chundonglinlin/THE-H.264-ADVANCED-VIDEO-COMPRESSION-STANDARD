# H.264 变换与编码

## 7.1 引言

第 6 章描述了 H.264 编码器的前端--预测处理，即通过创建和减去当前图像数据块的估计值来消除一些冗余。这个“前端”预测阶段是无损的，即它是一个完全可逆的过程，不会丢失数据。然而，H.264 基本上是一种有损压缩格式，在这种格式中，视频信号中引入一定程度的视觉失真，作为更高压缩性能的权衡。这种失真发生在变换/量化过程中。在早期的标准中，在变换(将一块图像样本转换为不同的域)和量化(降低变换系数的精度)之间存在明显的边界。在 H.264 编码中，该边界不再明显，具有变换和量化的重叠。与精度制定可逆整数变换核心的新方法一起，使得 H.264 变换和量化阶段与早期的压缩标准显著不同。

经过预测、变换和量化后，视频信号被表示为一些列量化的变换系数和预测参数。这些值必须被编码成可以有效传输或存储的比特流，并且可以被解码以重构视频信号。H.264/AVC 提供了几种不同的机制将参数转换成压缩比特流，即固定长度二进制码、可变长指数 Golomb 码、上下文自适应可变长码(CAVLC)和上下文自适应二进制算术编码(CABAC)。

在本章中，我们将介绍 H.264 变换和量化过程，并展示二进制编码如何完成将原视频信号转换为 H.264/AVC 压缩比特流的过程。

## 7.2 变换与量化

### 7.2.1 H.264 变换

H.264/AVC 指定了变换和量化处理，这些处理旨在提供视频数据的有效编码，消除编码器和解码器之间的不匹配，并促进低复杂度实现。

早期的图像和视频压缩标准(如 JPEG、MPEG-2 视频和 MPEG-4 视频)规定了将应用于源或剩余数据的二维离散余弦变换(2-D DCT)。

在H.264/AVC和其他最新标准（如VC-1）中，变换和量化过程被设计为最小化计算复杂度，适合使用有限精度整数算法实现，并避免编码器/解码器失配。这是通过以下方式实现的：  

* 使用一个核心变换(整数变换)，可以使用整数或定点算法和。
* 将归一化步骤与量化过程集成，以最小化处理剩余数据块所需的乘法次数。

标准中明确规定了解码器执行的缩放和逆变换过程，因此每个H.264实现应产生相同的结果，消除不同变换实现之间的不匹配。

### 7.2.2 变换处理

以下各节描述亮度和色度系数的变换/逆变换和量化/反量化过程。

#### 7.2.2.1 变换处理的概述

在 H.264/AVC 标准中定义了逆变换和重缩放或反量化过程，如图 7.1。这些过程必须在每个符号 H.264 的解码器中实现。相应的正变换和量化过程不是标准化的，但是等效过程可以从逆变换/重缩过程中导出(如图 7.2)。

在 H.264 编码器中，对残差系数进行变换和量化(如图 7.2)。基本变换“核心变换”是 4x4 或 8x8 整数变换，它是DCT变换的缩放近似。在某些情况下，此整数变换的部分输出进一步进行 DC 变换，使用 Hadamard 变换。变换系数被缩放和量化。  

相应的逆过程如图 7.1 所示。如果存在 DC 逆变换，则在重新缩放之前执行。缩放后的系数使用 4x4 或 8x8 整数逆变换。

#### 7.2.2.2 亮度变换过程

图 7.3 所示，luma 样本的正向过程被应用，除非(a)宏块编码使用 16x16 帧内预测(第 6 章)或(b) 一个宏块选择 8x8 整数变换，仅在 High Profile 中使用，见第 8 章。默认情况下，宏块的 16x16 luma 区域内的 4x4 块进行变换(Cf4)、缩放和量化(Mf4)以生成 4x4 块的量化变换系数。系数块按照从 0 到 15 的顺序，进行编码和传输。相对应的逆过程如图 7.4 所示。  

如图 7.5，如果宏块预测使用 16x16 帧内预测，第二个变换应用于第一个变换的最低或“DC”频率系数。这些 DC 值趋向于高度相关，并且第二个变换提升编码性能。首先，Cf4 应用到样本的每个 4x4 块。其次，系数的每个 4x4 块的 DC 系数组合成为一个 4x4 DC 系数块。该 DC 系数块使用 4x4 Hadamard 变换。变换后的 DC 系数块和每个块中剩余的 15 个 AC 系数被缩放和量化(Mf4)，并按照图7.5 所示的顺序传输。图 7.6 显示了再解码端执行的逆过程。注意，4x4 DC变换发生在缩放和反量化之前，这是为了在反变换过程中优化动态范围。

如果为该宏块启用可选的 8x8 变换(仅在 High Profile 中可用)，对于使用帧内 8x8 预测或任何帧间预测模式编码的宏块，应用图 7.7 所示的过程。每个 8x8 的 luma 样本块被变换(C<sub>f8</sub>)、缩放和量化(M<sub>f8</sub>)并传输，如图 7.8 所示，具有相应的逆过程。

#### 7.2.2.3 色度变换过程

420 格式宏块的色度分量（16x16 亮度样本，8x8 CbCr 样本）的处理过程如图 7.9 所示。对每个Cb 或 Cr 样本的 4x4 块进行变换(C<sub>f4</sub>)。每个块的 4 个 DC 系数用 2x2 Hadamard 或 DCT 变换进一步变换。标记为 0 和 1 的两个 DC 块（后面跟着 AC 块 2 到 9），被缩放、量化和传输。请注意，在逆过程中，在缩放和逆量化之前应用逆直流变换(图 7.10)。

422 格式宏块包含 8x16 Cb 和 Cr 样本(图 7.11)。每个4x 块进行变换(C<sub>f4</sub>)，并用 2x4 Hadamard 变换进一步变换 8 个 DC 系数。对两个 DC 块 0 和 1，以及随后的 AC 块 2 到 17 进行缩放、量化和传输。逆过程如图 7.12 所示，同样，青注意 DC 逆变换和缩放/逆量化的顺序。

444 格式宏块的色度分量与亮度分量的大小相同，Cb 和 Cr 中各有 16x16 各样本，如图 7.3(默认)、图 7.5（如果宏块使用 16x16 帧内预测编码）或图7.7(如果选择 8x8 变换和宏块使用 8x8 帧内预测编码)所示处理每个色度分量。

### 7.2.3 整数变换和量化：4x4 块

4x4 块的正、逆整数变换过程如下：  

* 从 4x4 DCT 开始，导出 DCT 的缩放整数近似值。
* 添加规范化步骤，以保持 DCT 的正交特性。
* 将归一化步骤与量化过程相结合。
* 指定标准中定义的逆缩放和量化过程。推导了等效的前向标度和量子化过程。

### 7.2.4 整数变换和量化：8x8 块

8x8 块的正变换和反变换方式与4x4 整数变换类似(第 7.2.3.1 节)，但有以下区别：  



## 7.3 块扫描顺序

在熵编码之前，扫描变换系数块，即转换为线性阵列。扫描顺序旨在将有效系数（即非零量化系数）组合在一起。在渐进帧中的典型块中，非零系数倾向于聚集在左上角的“DC”系数周围（第3章）。在这种情况下，锯齿扫描顺序可能是最有效的，如图7.17、4×4和8×8块所示。在以之字形顺序扫描块之后，将系数放置在线性阵列中，其中大多数非零系数倾向于出现在阵列的开始附近。

然而，在隔行扫描场或从隔行扫描内容转换的逐行扫描帧的场中，每个块中的垂直频率往往占主导地位，因为该场是从原始场景垂直亚采样的（第3章）。这意味着非零系数往往出现在块的顶部和左侧。因此，字段宏块中的块将按照修改后的字段扫描顺序进行扫描（图7.18）。

## 7.4 编码

编码的H.264流或H.264文件由一系列编码符号组成。这些符号构成第5章中描述的语法，包括参数、标识符和定界码、预测类型、差分编码的运动矢量和变换系数。H.264/AVC标准规定了用于对符号进行编码的几种方法，即，将每个符号转换为作为比特流的一部分传输或存储的二进制模式。这些方法如下：

* **定长编码**：符号转换为具有指定长度（n位）的二进制代码。
* **指数 Golomb 变长编码**：符号表示为具有可变位数(v bits)的 Exp-Golomb 码子。通常，较短的 Exp-Golomb 码子被分配给出现频率较高的符号。
* **CAVLC**：上下文自适应变长编码，一种特殊设计的变换系数编码方法，其中使用上下文自适应，根据最近编码的系数的统计信息选择不同的变长码集。
* **CABAC**：上下文自适应二进制算术编码，一种算术编码方法，其中概率模型根据先前的编码统计数据进行更新。

在 slice 数据层级（第 5 章）以上的语法中出现的符号使用固定长度代码或 Exp-Golomb 代码进行编码。 slice 数据以下的付好采用两种方式之一进行编码。如果选择了 CABAC 模式，所有这些符号都使用 CABAC 编码；否则，将使用 CAVLC 对系数值进行编码，并使用固定长度或 Exp-Golomb 代码对其他符号进行编码。

### 7.4.1 指数哥伦布编码

指数哥伦布码是根据规则模式[x,xi]构造的长度可变的二进制码。可变长度二进制码(如ExpGCodes)可用作以下不同概率表示数据符号的有效方法(第 3 章)。通过将短码字分配给频繁出现的数据符号，将长码字分配给不太常见的数据符号，可以以压缩形式表示数据。

表7.9 列出了由参数 code num 索引的前几个 Exp Golomb 码字。从表中可以清楚地看出，这些代码具有规则的逻辑结构。指数 Golomb 码是一种具有如下性质的变长码：i.代码长度随索引代码数的增加而增加 ii. 每个代码都可以在逻辑上构造，并通过算法解码，而无需查找表。   

表7.9 Exp-Golomb Codewords  
| code_num | Codeword |  
|:-------:|:-------:|  
| 0 | 1 |  
| 1 | 010 |  
| 2 | 011 |  
| 3 | 00100 |  
| 4 | 00101 |  
| 5 | 00110 |  
| 6 | 00111 |  
| 7 | 0001000 |  

指数哥伦布(Exp-Golomb)码字具有以下结构：[Zero prefix][1][INFO] 码字由 M 个零的前缀(其中 M 是 0 或正整数)、1 和 M 位信息字段 INFO 组成。每个码字可以从参数 code num 通过算法生成： M = floor(log_2[code_num + 1])  INFO = code_num + 1 - 2^M 

相反，可以使用如下解码获取 code_num： 1. 读取一系列连续的零，直到检测到1。计算零的数量（M）。2. 读取 1 (ignore)。3. 读取 M 个位 = INFO。4. code_num = 2^M + INFO - 1。

### 7.4.2 上下文自适应变长编码(CAVLC)

上下文自适应变长编码(CAVLC)用于对变换洗漱的剩余扫描有序块进行编码。CAVLC[xii] 旨在利用量化系数块的若干特性：

1. 在预测、变换和量化之后，块通常是稀疏的，通常包含大部分零。CAVLC 使用运行级编码来紧凑地表示零字符串。
2. 块扫描后的最高非零系数通常是+/-1和 CAVLC 表示高频信号的数量+/-1系数，“Trailing 1s”或“T1s”，以紧凑的方式。
3. 相邻块中非零系数的数量是相关的。使用查找表对系数的数目进行编码，并且查找表的选择取决于相邻块中非零系数的数目。
4. 非零系数的 level 或大小在扫描阵列开始时，在 DC 系数附近往往更大，而在频率较高时则更小。CAVLC 利用这一点，根据最近编码的level 大小，调整参数 VLC 查找表的选择。

如果 CAVLC 与 8x8 整数变换一起使用，则量化变换系数的每个 8x8 块被处理为四个 4x4 块，用于 CAVLC 编码和解码。

图 7.19 显示了 CAVLC 编码过程的简化概述。使用 Z 字形或场扫描扫描系数块，并将其转换为一系列可变长度编码(VLC)。某些 VLC 表是基于局部统计信息选择的，即相邻块中非零系数的数量和最近编码系数的大小。4x4 变换系数块的 CAVLC 编码如下进行。

**1. 对系数和尾随系数的数量进行编码(coeff_token)**  

第一个VLC(coeff_token)对非零系数的总数(token_)

## 7.5 总结

在帧内或帧间预测之后，对宏块中的剩余数据块进行变化、量化、扫描和编码。H.264/AVC 编解码器使用许多变换，这些变换基于众所周知的 DCT 和 Hadamard 变换，但具有某些新颖的方面。与以前的标准相比，每个逆变换都是使用整数算法精度指定的。通过将变换的一部分"吸收"到量化器过程中，可以有效实现变换和量化。

H.264 编码器将视频信号转换为一组量化的变换系数、运动矢量、预测参数和报头参数。对这些值进行编码以生成压缩比特流。编码器可以在可变长度编码(对某些语法元素使用指数 Golomb 码)和对剩余块使用定制设计的上下文自适应可变长度编码算法，或上下文自适应二进制算术编码器之间进行选择。


